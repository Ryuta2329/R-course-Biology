[["index.html", "Prefacio", " Prefacio "],["empezando-comandos-básicos..html", "1 Empezando: Comandos Básicos.", " 1 Empezando: Comandos Básicos. Lo primero para utilizar R es asegurarte que lo tengas instalado en tu computadora. R esta disponible para diferentes sistemas operativos en Comprehensive R Archive Network (CRAN). En Windows, debes descargar el instalador R.exe y luego ejecutarlo y seguir las instrucciones. En distribuciones de Linux puedes hacerlo de forma manual descargando los binarios y luego instalando from source, o lo puedes hacer desde el repositorio usando la herramienta apt-get (para Ubuntu 20.04 LTS esta guía puede ser útil. Además, contiene una guía para instalar el paquete tidyverse en este sistema operativo). "],["el-entorno-de-trabajo..html", "1.1 El entorno de trabajo.", " 1.1 El entorno de trabajo. Una vez instalado R, lo inicializas ejecutando el icono Rgui.exe (Windows) o escribiendo R (Linux) en la terminal. Esto hará que aparezca la terminal de comandos de R que espera por ti a que ejecutes tus comandos. El punto de entrada de comandos se reconoce por el símbolo &gt;, y es el indicador de que se ha iniciado una nueva sesión de R de forma exitosa. Una vez iniciado R, este denomina a uno de los directorios en tu disco duro como directorio de trabajo (working directory en ingles), que es donde R busca por cualquier archivo, programa o datos pertenecientes al usuario (¡a ti!) el cual quieras utilizar. Una forma de determinar cual es el directorio de trabajo es usando la función getwd() (ahí dice: obtener directorio de trabajo en ingles). Por lo general, si vas a usar R para procesar y analizar tus propios datos o guardar resultados (bases de datos procesadas, imágenes o archivos) entonces debes de poder cambiar de directorios1. Para este proceso existe la función setwd(\"tu/directorio/personal\") (ahí dice: establecer directorio de trabajo en ingles), donde “tu/directorio/personal” es la dirección donde se encuentra tu carpeta personal en el disco duro 2. Por ejemplo, supongamos que tienes una o mas bases de datos que quieres procesar en una carpeta llamada “misDatos” que se encuentra en “C:” (el disco duro por omisión en Windows). Para cambiar a este directorio escribirías en R: setwd(&quot;C:/misDatos&quot;) Los directorios los puedes entender como carpetas dentro de otras carpetas: por ejemplo, los documentos guardados en una carpeta llamada, digamos, “Mi Carpeta Personal” que se encuentra en el escritorio de Windows se encuentran en la dirección \"C:/users/Tu Usuario/Desktop/Mi Carpeta Personal\". Mi recomendación es que guardes todos tus archivos en una carpeta personal que tenga una estructura clara y bien organizada como la que se muestra en la figura ??. Esa es la forma como estructura mi directorio de trabajo: Buenas prácticas de programación. Esta es una forma de mantener una estructura consistente y portable de organizar tus archivos y que es usada por otros programadores. Recuerda, es posible que tus programas no solo los termines usando tú, sino que otras personas también. En la carpeta Data se encuentran todas las bases de datos: archivos de Excel (.xlsx), de valores separados por coma (.csv), de datos (.dat), de datos de R (.Rdata), y otros3. En la carpeta ext se encuentran scripts de R (.R) que contienen funciones con funciones especificas que yo mismo escribí o que fueron escritas por alguien más. En output coloco toda la información que quiero guardar como gráficos (.jpeg, .png, .tiff, etc.), archivos PDF o de Word (.docx). En src (esto es abreviado para source code) se encuentran todos mis scripts de R, así como archivos de rmarkdown (.Rmd)4. Otra forma de mantener estructuras organizadas es por medio de la creación de proyectos en RStudio. Yo no he usado RStudio y por lo tanto no comentare al respecto, pero puedes encontrar un tip interesante en @RTips, y existen otros artículos en Internet que puedes consultar. Puedes encontrar una explicación acerca de los directorios en aquí↩︎ Las comillas son obligatorias. Mas adelante cuando aprendas sobre la representación y los tipos de datos sabrás porque.↩︎ Las palabras luego del punto que se encuentran entre paréntesis se conocen como extensiones del archivo o formato del archivo. Todos los archivos de Excel finalizan con la extensión .xlsx, y ese es su formato (aunque uno le diga formato de Excel). De igual forma, otras extensiones definen otros formato de datos y cada uno representa el contenido del archivo de una forma particular (puedes pensar en la diferencia en como se representa la data en un archivo PDF y uno de Word).↩︎ Otras personas llaman a esta carpeta R en lugar de src. La razón de porque yo la llamo src es porque tengo en esta carpeta otros programas con otras extensiones diferentes a la de R (.pl, .py, .cpp, .h, .md, .jl, etc.).↩︎ "],["usando-la-consola-operaciones-matemáticas-en-r..html", "1.2 Usando la consola: operaciones matemáticas en R.", " 1.2 Usando la consola: operaciones matemáticas en R. Una vez instalado R, ya puedes empezar a utilizarlo escribiendo comandos y luego presionando la tecla de Retorno (Enter) para ejecutarlos. Un uso básico de R como entorno es como calculadora científica, realizando operaciones matemáticas sencillas: 100 + 32 # Suma 54 - 85 # Resta 72 * 8 # Multiplicación 54 / 3 # División Además de estas, existen otras operaciones matemáticas: la exponenciación (p. ej. 2 ^ 4 o alternativamente 2 ** 4. Ambos dan el mismo resultado), el módulo (10 %% 3, devuelve el resto de la operación de división), y la división entera (10 %/% 3, regresa la parte entera del resultado de dividir el operando izquierdo entre el derecho, en este caso, regresa 3). También puedes agrupar las operaciones usando paréntesis para especificar el orden en el que se hacen las operaciones matemáticas. Por ejemplo: 100 + 3 / 5 + 1 # 101.6 (100 + 3) / 5 + 1 # 21.6 100 + 3 / (5 + 1) # 100.5 (100 + 3) / (5 + 1) # 17.16667 En el código anterior, todos los resultados son diferentes porque el orden en el que se evalúan las operaciones es distinto debido a la presencia de los paréntesis. Las operaciones en paréntesis siempre se evalúan primero, seguido se evalúan todas las multiplicaciones y divisiones, y por ultimo las sumas y restas. De igual forma, si hay operaciones de exponenciación, estas se evalúan después de las operaciones en paréntesis y antes de las divisiones y multiplicaciones. Esto es lo que se conoce como precedencia de operaciones. Puede ocurrir que al introducir los datos nos falte algún termino o no hayamos cerrado los paréntesis completamente, etc. En esto casos, R mostrara el símbolo de continuación de comando +, en lugar del símbolo usual, &gt;. Esto solo quiere decir que R esta esperando por mas comandos para completar la linea de código. Termina el comando o presiona la tecla Esc para terminar el comando sin que se ejecute. También se pueden llevar a cabo el calculo de las funciones usuales como el valor absoluto (p. ej. abs(8)), la exponencial (p. ej. exp(1)), el logaritmo natural (p. ej. log(10)) o el logaritmo en cualquier otra base (p. ej. log(10, 5) arroja el logaritmo en base 5 de 10. Existen funciones logarítmicas en bases usuales como 2 (log2()) o 10 (log10()) debido a que son de uso rutinario en ciertas aplicaciones), la raíz cuadrada (p. ej. sqrt(2)), y funciones trigonométricas (p. ej. cos(pi/4), sin(pi/4), y tan(pi/4). R reconoce a pi como la constante numérica \\(3.1415926535...\\) Las funciones inversas son acos, asin y atan). Por omisión, R muestra en los resultados solo 7 cifras significativas. Esto lo puedes cambiar usando options(digits = numero). Por ejemplo, si quieres que se muestren, digamos, 10 cifras significativas usas options(digits = 10). También puedes redondear hacia arriba o hacia abajo los resultados de operaciones usando las funciones ceiling y floor, respectivamente. Pon en práctica lo que aprendiste. Escribe en R las siguientes operaciones matemáticas y obtén los resultados: \\(1 + \\frac{5}{15 + 8}\\) \\(\\sqrt{3^2 + 4^2}\\) \\(\\frac{10}{10 + \\text{e}^{1.5\\times20}}\\) "],["asignación-de-variables..html", "1.3 Asignación de variables.", " 1.3 Asignación de variables. Otra operación común en las matemáticas es asignarle a una variable un valor. En R, esto también puede realizarse, de forma que se pueda almacenar en memoria un número o una palabra, o incluso el resultado de operaciones matemáticas. Para llevar a cabo la asignación se utiliza el operador de asignación (Duh!), &lt;-. Por ejemplo, si quieres asignarle el resultado de obtener la raíz cuadrada de 32 a la variable x, se escribe: x &lt;- sqrt(32) A este proceso de asignarle un valor a una variable se le denomina declaración o instanciación de variables: en este caso, se ha declarado la variable x asignándole el valor de sqrt(32). Una vez declarada, se puede ver el valor escribiendo el nombre de la variable en la consola y seguido presionando Enter. A esto se le llama llamar a la variable (call en ingles). Hay otras dos formas de llamar a una variable: usando la función print, pasando la variable como argumento (en el ejemplo anterior, si quisieras llamar a x podrías hacerlo con el comando print(x)). De hecho, cuando llamas una variable usando solo su nombre en la consola, lo que esta sucediendo es que se llama a la función print de manera implícita. La segunda forma es haciendo uso de la función cat, la cual permite imprimir en pantalla lo que se encuentra almacenado en una variable (o el resultado de una llamada a una función) sin que se muestren las comillas. Esto permite una forma más estilizada de presentar resultado. Buenas prácticas de programación. En una nota aparte, en la web vas a encontrar mucho código de otros programadores en el cual utilizan el operador = como operador de asignación en lugar de &lt;-. Aunque esto no es errado (la única diferencia entre = y &lt;- es que el último tiene mayor precedencia que el primero), la convención es usar &lt;- como operador de asignación, y reservar el operador = como un símbolo de sintaxis que señala el paso de un argumento en la llamada a una función5. Ahora, hay algunas reglas en el uso de nombres de variables: los nombres de las variables pueden contener solamente letras, números y/o punto (.) o un piso (_), siempre y cuando no empiecen con una letra o con el punto pero nunca pueden empezar con un punto seguido de un número (parece una regla bastante larga). Por ejemplo, variables como x, my.variable, my_variable_2 o .dot son nombres de variables aceptables; pero 2_x, _wrong, o 3error no estan permitidas. Buenas prácticas de programación. Una nota importante sobre el nombre de las variables es que estos deben de significar algo, en el sentido que debe ser explicativo. Por ejemplo, si asignas el resultado de sumar 5 + 8 a una variable, un buen nombre para la variable sería suma. Si se trata de una operación más complicada, de repente resultado sea un buen nombre. No le asignes nombres aleatorios a las variables, eso solo hará que te pierdas y hará más difícil de leer el código, y aún más difícil el tener que mantenerlo y modificarlo (así que nada de llamar variables como tu crush. A él/ella no le importas y a nosotros tampoco). Otro punto con respecto a esto, esta en el estilo o convenciones. Los programadores utilizan distintos estilos para nombrar las variables y puedes adherirte a alguno de ellos. Lo importante es que te mantengas consistente. Algunos estilos o convenciones son los siguientes: namingconvention naming.convention naming_convention namingConvention NamingConvention Por lo general, uno al principio prueba varios estilos y termina adhiriéndose a uno que nos hace sentir bien al leerlo y escribirlo. Asi que haz varias pruebas y elige el que te haga sentir más cómoda. Finalmente, en R hay lo que se conoce como palabras reservadas. Estas son caracteres o combinación de caracteres especiales que R utiliza para definir ciertos componentes del lenguaje. Por ejemplo, algunas palabras reservadas son NA para valores faltantes, o TRUE y FALSE para los valores lógicos. Como están reservadas para usos específicos, estas palabras no pueden ser utilizadas como nombres de variables (p. ej. la declaración NA &lt;- 25 resultará en un error. NA es un carácter reservado). Wow! Aun no hablamos de funciones y puede que no sepas que son los argumentos, pero ya pronto lo sabrás. Por ahora solo tómame la palabra y usa &lt;- cada que asignes valores a variables↩︎ "],["tipos-de-datos-y-su-manejo..html", "1.4 Tipos de datos y su manejo.", " 1.4 Tipos de datos y su manejo. Dentro de R, todas las variables están representadas como objetos y estos pueden manipularse de acuerdo las necesidades. La mayoría de los objetos, son o están compuestos por vectores (de hecho, R esta completamente vectorizados y esta es la estructura de datos más importante de la que hablaremos), y estos vectores pueden estar formados por uno de varios tipos básicos de datos: datos numéricos, caracteres, valores lógicos, o fechas. Para saber el tipo de dato que compone a un vector se puede utilizar la función typeof(). 1.4.1 Datos numéricos. Los datos numéricos pueden ser de uno de tres tipos: o double, que es el tipo de dato numérico por omisión, y se usa para representar cualquier número real en R. Otra clase de objetos numéricos corresponde a integer, que se usa para representar números enteros solamente. Para crear enteros simplemente coloca una L seguido del número: # Crea un entero my_int &lt;- 4L # Verificando typeof(my_int) R usa de forma intercambiable double e integer durante las operaciones matemáticas y en general no te daras cuenta cuando aparezcan enteros. Pero en ciertos casos es útil utilizar enteros ya que ocupan menos memoria (necesitas menos bytes para almacenar un integer en memoria que para almacenar un double). Finalmente, el último tipo de dato numérico es el complex que se usa para representar números complejos: aquellos que presentan dos partes, una real y una imaginaria que viene representada por un múltiplo de \\(i\\) (\\(i\\) se define como \\(i = \\sqrt{-1}\\)). Puede que nunca te encuentres con estos en tu vida, pero los números complejos tienen muchas aplicaciones en física, matemáticas e ingeniería, y aparecen en varios tópicos interesantes en biología. La manera de escribirlos en R es la siguiente: # Un número complejo my_complex &lt;- 1 + 2i # Verificas typeof(my_complex) Un punto interesante, si tomas la raíz cuadrada de un número negativo vas a obtener como resultado NaN (este es un valor especial que significa Not a Number y que surge cuando intentas realizar operaciones matemáticas que dan como resultado valores indefinidos) seguido de una advertencia. La razón es que un número negativo en R se representa como un tipo double. Si quieres tener la raíz cuadrada de un numero negativo, este debe representarse primero como un número complejo: # -1 (la parte imaginaria esta multiplicada por cero, asi que el número es # real. Pero de esta forma, R entiende que se trata de un tipo de dato # `complex`) my_complex &lt;- -1 + 0i sqrt(my_complex) 1.4.2 Caracteres. Los caracteres o cadenas de caracteres son un tipo de dato que permite representar letras, palabras y frases en R. Para crear datos de tipo character solo tienes que escribir un cadena de caracteres entre comillas (“) o comillas sencillas (’)6. Puedes usar la función nchar para conocer la longitud de una cadena de caracteres. hello &lt;- &quot;Hello World!&quot; hello nchar(hello) # 12: el espacio en blanco cuenta como un caracter. Date cuenta, que los espacios en blanco son un tipo de caracter también. Claro, existen funciones especificas que facilitan el manejo de cadenas de caracteres en R. Por ejemplo, la función paste permite unir dos cadenas de caracteres: paste(&quot;Hello!&quot;, &quot;R is fun&quot;, &quot;right?&quot;) paste(&quot;Too&quot;, &quot;many&quot;, &quot;underscores!&quot;, sep=&quot;_&quot;) La última línea de código utiliza el argumento sep de la función paste para especificar el separador que se coloca entre las cadenas de caracteres que se unirán. Puedes colocar cualquier separador que te parezca, incluso espacios vacíos (““). También puedes llevar a cabo el proceso inverso: tomar una cadena de caracteres y separarla en pedazos cada vez que se encuentre una coincidencia con respecto a un patrón7 particular. Por ejemplo: strsplit(&quot;Break it Ralph! Break it!&quot;, &quot; &quot;) rompe la cadena \"Break it Ralph! Break it!\" en subcadenas cada vez que encuentra una ocurrencia del patrón ” ” (un espacio en blanco), a saber, \"Break\", \"it\", \"Ralph!\", \"Break\" e \"it!\". Además, puedes obtener subcadenas a partir de una cadena utilizando la función substr. Por ejemplo, substr(\"This is my string\", 9, 17) extrae de la cadena \"This is my string\" una subcadena que empieza en el caracter 9 y termina en el 17 (ejecuta el comando para que observes el resultado). Otras funciones útiles lo son: i) Convertir un número en una cadena de caracteres: p. ej. as.character(10). ii) Todo en minúscula (tolower()) y todo en mayúscula (toupper()). iii) Reemplazo de caracteres: puedes reemplazar todas las ocurrencias de un caracter en una cadena por otro. Por ejemplo: r &lt;- &quot;La r en R es mayuscula!&quot; chartr(r, old = &quot;r&quot;, new = &quot;R&quot;) reemplaza todas las ocurrencias de r por una R. También funciona si usas mas de un caracter para reemplazar, siempre y cuando coloques por cual lo vas a reemplazar: change_two &lt;- &quot;dexduzl znzlysis&quot; chartr(change_two, old = &quot;dz&quot;, new = &quot;ta&quot;) En este caso, todas las d son reemplazadas por una t, mientras que las z son reemplazadas por a. Esto es, el caracter original (old) en la \\(i\\)-esima posición es reemplazado por la coincidencia encontrada en el caracter nuevo (new) en la misma posición. Es por esto que las cadenas pasadas a los argumentos old y new deben contener el mismo número de caracteres. 1.4.3 Valores lógicos. Estos corresponden a uno de dos posibilidades: TRUE (verdadero) o FALSE (falso), los cuales son comúnmente utilizados en la toma de decisiones dentro de estructuras de control (Woops! Adelantándome otra vez. Ya pronto sabrás de que trata), y se pueden abreviar usando T o F. Estos valores, son el resultado de evaluar expresiones condicionales o relacionales. Estas expresiones se pueden identificar porque utilizan los operadores relacionales &lt; (es menor que), &gt; (es mayor que), &lt;= (es menor o igual que), &gt;= (es mayor o igual que), == (igualdad), y != (desigualdad). Por ejemplo, supongamos que tienes un variable v a la cual le asignas el valor de 100. Puedes utilizar las operaciones relacionales de la siguiente forma: v &lt;- 100 v &gt; 5 # TRUE: 100 si es mayor a 5 v &lt; 50 # FALSE: 100 no es menor a 50 v == 100 # TRUE: 100 es igual a 100 v != 1000 # TRUE: 100 es diferente de (o no es igual a) 1000 Si utilizas la función typeof sobre el resultado de una operación lógica, el resultado te dirá que el resultado es un valor lógico (p. ej. typeof( v &gt;= 65) arrojara logical como resultado. ¡Pruebalo!). Por último, existen funciones que devuelven valores lógicos y son utiles para saber si una variable particular corresponde a un tipo de dato dado. Estas funciones son de la forma is.*, donde el asterisco corresponde a algun tipo de dato que quieras comprobar. Por ejemplo, num &lt;- 1457 # Un numero int &lt;- 65L # Un entero boo &lt;- &quot;Boo!&quot; # Una cadena de caracteres logic &lt;- num &gt; int # Un valor lógico # Uso de las funciones is.* is.numeric(num) is.integer(int) is.character(boo) is.logical(logic) confirman que las variables declaradas corresponden a sus tipos de datos asignados. Es por ello que todas las funciones arrojan TRUE al ejecutarlas (¿Los ejecutaste para comprobarlo?). También podrías haber evaluado el comando is.numeric(logic). En este caso, el resultado es FALSE, porque logic es una variable de tipo logical, no numeric. 1.4.4 Fechas y tiempo. Las fechas y el tiempo son unas de esas cosas que todos creemos manejar fácilmente, pero que en la practica se convierten en difíciles de tratar. La razón de esto es que las fechas y el tiempo dependen de dos factores: el movimiento de rotación y traslación terrestre, en conjunto con los problemas geopolíticos de asignar zonas horarias. Puedes obtener la hora actual, así como fecha y la zona horaria utilizando las funciones Sys.timezone(), Sys.Date(), Sys.time(). Sin embargo, hay veces en las que hay que tratar con fechas y horas que no corresponden al actual y, por lo general, estas son importadas a R en forma de caracteres. Por lo tanto, estas se deben de convertir a objetos de clase Date o POSIXct (en el caso de horas)8 antes de poder usarlas. Puedes hacerlo de la siguiente forma: # El formato por omisión es YYYY-MM-DD (año, mes, día) as.Date(&quot;1994-10-29&quot;) # A veces es mejor especificar el formato as.Date(&quot;29/10/1994&quot;, format = &quot;%d/%m/%y&quot;) Date cuenta que el separador de los componentes de la fecha puede ser distinto: en el ejemplo, una fecha usa como separador “-”, mientras que la otra usa “/”. Otros separadores comunes son el punto (“.”) o sin separador (““). Si utilizas la función typeof sobre un objeto de la clase Date o POSIXct el resultado será double: esto es así porque internamente R representa las fechas y horas como números de punto flotante. También puedes crear un objeto de clase POSIXct usando la función ISOdate, la cual recibe literales de cadena especificando el año, mes, día, hora, minuto, segundos, e incluso zona horaria (p. ej. ISOdate(year = \"2020\", month = \"03\", day = \"10\")). Luego, puedes convertir este a una fecha (objeto de clase Date) usando as.Date al igual que antes. Una funcionalidad mas acerca de las fechas y horas, es que puedes realizar cálculos con estas: # Cálculos con fechas x &lt;- Sys.Date() # Fecha Actual y &lt;- as.Date(&quot;2020-03-01&quot;) # Por ahí inicio la pandemia por Sars-CoV-2 x &gt; y # Operaciones lógicas con fechas x - y # Te dice cuantos días de diferencia hay entre ambas fechas # Cálculos con zonas horarias x &lt;- as.POSIXct(&quot;2015-09-22 01:00:00&quot;, tz = &quot;Europe/Madrid&quot;) y &lt;- as.POSIXct(&quot;2015-09-22 01:00:00&quot;, tz = &quot;America/Caracas&quot;) y == x # Operaciones lógicas con zonas horarias y - x # Te dice cuantos horas de diferencia hay entre ambas zonas Si no conoces cuales son las zonas horarias, no hay problema. R provee una función que te muestra todas las zonas horarias: OlsonNames(). Pon en práctica lo que aprendiste. Crea un objeto de clase Date que contenga tu fecha de nacimiento. Calcula cuantos días y tiempo falta para tu próximo cumpleaños. 1.4.5 Otros valores especiales. R tiene algunos valores especiales que deben tratarse con cuidado. Algunos de ellos ya han aparecido: Valores faltantes (NA o Not Available): aparecen a menudo cuando se importan datos en los cuales no se han registrado algunas observaciones. Puedes verificar que el valor almacenado en una variable es un NA usando la función is.na(). Valores no numéricos (NaN o Not a Number): aparecen cuando se tratan de realizar operaciones que arrojan resultados indefinidos. Ya vimos un ejemplo con la raíz cuadrada de un número negativo. Otro ejemplo ocurre cuando tratas de realizar la operación 0/0. Infinitos (Inf o Infinite): aparece cuando se tratan de realizar operaciones cuyo resultado es un valor muy grande. Por ejemplo, aparece cuando tratas de hacer la operación 1/0. También se pueden obtener infinitos negativos cuando hay negativos involucrados en la operación (p. ej. -1*Inf). En R es indiferente si usas comillas dobles o sencillas para definir caracteres, el resultado final será el mismo. La razón de la existencia de ambos es que para escribir en una computadora unas comillas simple solo tienes que presionar una tecla, mientras que para la comillas dobles tienes que presionar dos teclas (por lo general, shift + 2, aunque depende de como este configurado tu teclado). Los programadores son flojos, y siempre que puedan ahorrarse el tiempo de presionar aunque sea una tecla, lo harán. Aunque en R ya esta tan extendido el uso de las comillas dobles, que será raro que encuentres código con comillas simples.↩︎ Un patrón hace referencia a una expresión regular o regex (por regular expression) el cual simplemente es una expresión (cadena o secuencia de caracteres) que define un patrón de búsqueda. Este es un tema muy extenso y puede que no se cubra en este texto.↩︎ Esto de las clases y los objetos se volverá más importante y lo aclararé mas adelante. Por ahora solo es necesario que entiendas que los objetos representados en R pertenecen a clases particulares (p. ej. las fechas corresponden a objetos de la clase Date) los cuales pueden tener atributos particulares que definen algunas características del objeto (p. ej. un atributo de un vector es la longitud, esto es, cuantos elementos contiene el vector).↩︎ "],["organizandote-scripts..html", "1.5 Organizandote: Scripts.", " 1.5 Organizandote: Scripts. A medida que escribas programas cada vez más complejos y grandes, va a ser necesario que lleves registro y los puedas almacenar en una forma que sea accesible y fácil de modificar. Para esto, es necesario que crees scripts: archivos de textos que contienen los comandos de tu programa organizados de forma secuencial y ordenada. Los scripts son archivos de textos y es por eso que solo necesitas un editor de texto para crearlos (p. ej. puedes hacerlos con el bloc de notas). Lo importante es que como estas creando programas de R, los scripts deben terminar con la extensión .R (los archivos de bloc de notas tienen extensión .txt por omisión. Tu puedes cambiar la extensión presionando el botón derecho del ratón sobre el archivo y seleccionando “Cambiar nombre”. Cambias la extensión a .R y presionas “Aceptar”). Un ejemplo de un programa sencillo es el que se muestra a continuación. Puedes copiar y pegar9 el código en un editor de texto y guardarlo como Suma.R: # Suma.R - Este programa se encarga de sumar dos números predefinidos aquí. # Números a sumar first &lt;- 16 second &lt;- 32 # Sumando suma &lt;- first + second suma En general, los programas que escribirás en scripts serán mucho mas grandes y complejos. Pero usaremos el programa Suma.R para ejemplificar ciertos aspectos del flujo de trabajo al programar en R. Todo lo mencionado en esta sección tiene que ver con el estilo y las convenciones utilizadas por los programadores de R para escribir scripts de forma elegante y que sea fácil de leer para otros programadores. Primero que nada, los nombres de los scripts, al igual que los nombres de variables y funciones, deben ser significativos o representativos. Estos deben dar una idea de a que esta dirigido el programa y no tener nombres aleatorios o que signifiquen algo trivial (de nuevo, nada del nombre de tu crush o de tu comida favorita). Tal vez no lo notaste, pero hemos estado usando con bastante frecuencia el símbolo #. Este símbolo indica que lo que sigue después del mismo hasta el fin de línea10 es un comentario. Los comentarios R los interpreta como partes del script que no se ejecutan. Son solo lineas de texto que están ahí para explicar para que sirve una parte del código o para mostrar información acerca del programa (un mal hábito que se suele adherir a nosotros debido a la inseguridad o necedad es el de comentar código que ya no usaremos o código que ya no se ejecuta debido a modificaciones posteriores. Trata de no hacer esto). En mi caso, cuando sé de antemano que el programa será leído por otras personas, añado también la fecha y mi dirección de correo electrónico (básicamente lo que hago es dándole un autor al programa). # molinatti.marc.029@gmail.com # Enero 7, 2021. Facilitar la legibilidad de un programa es importante, porque puede suceder que tu tengas que leer tus propios programas luego de que ha transcurrido mucho tiempo de haberlos escrito. Si el programa esta todo amontonado y sin un buen espaciado, será una tortura hacerlo (y si tu programa va dirigido a otras persona, esas personas te van a odiar y maldecirán por haberles dado un programa tan basura). Es por eso que existen ciertas convenciones cuando se trata de estilo: i) Los operados van separados de sus operandos por medio de un solo espacio, excepto si se trata de los operadores :, :: o :::; y ii) cuando una línea de código es muy larga (más de 80 caracteres) utiliza saltos de lineas y tabuladores11. # Una operación matemática correctamente espaciada... 1 + 32 / (6 * 4) # ...y una no tan bien espaciada. Ew! 55*sin(pi/4)+10 # Usa saltos de línea y tabulaciones para mejorar la lectura del código. y &lt;- as.POSIXct(&quot;2015-09-22 01:00:00&quot;, tz = &quot;America/Caracas&quot;) Esto solo por esta vez lo haremos. En general, copiar y pegar código es una mala practica de programación y no debe hacerse, debido a que hay mucha propensión a propagar errores, es más difícil de mantener y modificar si cambias algo en un fracción del código que copiaste y que debes modificar en todas las copias del mismo, y entre otras razones.↩︎ Un fin de línea (o \\n es un salto de linea. Cada vez que presionas Enter cuando escribes un texto en la PC, introduces un fin de línea.↩︎ Personalmente, los tabuladores no me gustan porque el espaciado por omisión es demasiado grande. Yo utilizo dos espacios en blanco como tabulador. Aunque también puedes modificar tu editor de texto para que el tamaño de la tabulación sea de dos espacios en blanco y no de 6 u 8.↩︎ "],["necesitas-ayuda-r-te-ayuda.html", "1.6 Necesitas ayuda: R te ayuda!", " 1.6 Necesitas ayuda: R te ayuda! R es un lenguaje de programación que esta demasiado bien documentado y que crece y mejora cada vez más gracias a la comunidad. Puedes acceder a la ayuda de R cuando lo desees. En esta se incluye información sobre los paquetes instalados y, por lo tanto, de las funciones que se encuentran en el entorno de R. Desde la consola, acceder a la ayuda de R es tan sencillo como usar la función help, o su sinónimo, ?. Por ejemplo, si quieres ayuda acerca de una función particular, digamos substr, puedes acceder a la documentación para esa función usando help(\"substr\") o ?substr. Si no conoces el nombre de la función puedes usar alguna palabra clave con la función help.search. Esta se encargará de mostrarte todas las funciones con la cadena que le pases como argumento (lo que entre paréntesis) en su nombre. Otras funciones útiles que son de ayuda, son las siguientes: * apropos: regresa una lista de todos los objetos (incluyendo nombres de variables y funciones) en la sesión actual que corresponden con la cadena de caracteres que pases como argumento. * example: muestra ejemplos de como usar una función. * vignette: da información más detallada acerca de una librería o paquete. No todos los paquetes tienen viñetas, pero las que lo tienen proveen una gran ayuda para comenzar a utilizar el paquete y entrenarte. Pon en práctica lo que aprendiste. Utiliza las funciones de ayuda de R para revisar la documentación de la función strsplit y utilízala para romper la cadena de caracteres \"Why?all?those?interrogation?symbols, eh?\" en cada aparición de un signo de interrogación. Utiliza la ayuda de R para investigar sobre la precedencia de operadores (Pista: Utiliza precedence como palabra clave). "],["comunicando-resultados-y-tomando-notas..html", "2 Comunicando Resultados y Tomando notas.", " 2 Comunicando Resultados y Tomando notas. Una parte importante del procesos de análisis de datos es la comunicación. Saber programar no es suficiente! Tienes que tener la capacidad de comunicar tus resultados en una forma que sea clara y apetecible para quienes esta dirigido. En este capitulo, la idea es aprender acerca de las tecnologías que ofrece R para este propósito, "],["instalando-paquetes-en-r..html", "2.1 Instalando paquetes en R.", " 2.1 Instalando paquetes en R. Las librerías en R son paquetes que contienen funciones que sirven para llevar a cabos tareas específicas, y algunos tienen datos que se pueden usar para llevar a cabo los ejemplos de las funciones incluidas en el paquete (esto se cargan en R usando el comando data). Cuando inicias una sesión de R, algunos paquetes se cargan por omisión, de forma que sus funciones estén disponibles para su uso en la sesión actual. Puedes saber que paquetes se cargan por omisión usando getOption(\"defaultPackages\"). Es casi imposible que no utilices otros paquetes más allá de los paquetes por omisión cuando estés realizando algún trabajo en R. Es bueno siempre llevar un registro de los paquetes que utilizas durante una sesión de R (una de las máximas de la programación literaria). Para poder ver que paquetes están cargados en la sesión actual puedes utilizar: print(.packages()). Este comando muestra todos los paquetes cargados en la sesión actual. Ahora, para poder cargar y usar los paquetes, estos deben estar disponibles en tu computadora para la sesión de R. Instalar paquetes en R es muy sencillo: ellos se pueden descargar e instalar desde un repositorio. Se utiliza la función install.packages para instalar un paquete desde el CRAN (necesitas tener conexión a Internet para poder instalar los paquetes). Puedes saber donde los paquetes son instalados utilizando .libPaths(), que te muestra la dirección del directorio en tu PC o laptop donde se encuentran instalados los paquetes. Si no puedes tener acceso a Internet en tu computadora personal o laptop, puedes instalar los paquetes desde una dirección local en tu computadora. Para esto, debes descargar los paquetes directamente desde el CRAN (archivos comprimidos con extensión .tar.gz) desde una computadora o laptop con conexión a Internet. Luego almacenarlos en un directorio conocido en tu computadora e instalar el paquete usando12: install.packages(&quot;ruta/donde/colocaste/paquete.tar.gz&quot;, repos = NULL, type = &quot;source&quot;) Una vez un paquete esta instalado puedes utilizar la función library para cargar el paquete. Por ejemplo, más adelante utilizaremos el paquete readxl que contiene funciones para leer y escribir archivos de Excel desde R (existen otros paquetes con estas funcionalidades, pero readxl tiene la ventaja de que los datos son cargados en forma de una estructura de datos llamada tibble, la cual es particularmente útil para trabajar en el tidyverso13). Es posible instalar este paquete utilizando intsall.packages(\"readxl\") (las comillas son obligatorias)14 y una vez instalado, cargarlo en la sesión actual usando library(\"readxl\"). R siempre esta mejorando! Como consecuencia, de tanto en tanto tendras que actualizar la version que tienes a una version mas reciente, o actualizar los paquetes de forma que puedas seguir usandolos. Para poder mantenerte al dia, siempre puedes verificar que paqutes no estan actualizados utilizando la funcion old.packages(), y puedes actualizarlos usando la funcion update.packages. Si el paquete ya lo has cargado previamente a la sesion de R usando library, tienes removerlo de la sesion actual par luego actualizarlo. Para ello puedes usar: detach(&quot;package:nombre_del_paquete&quot;, unload = TRUE) o puedes utilizar la funcion unloadNamespace como: unloadNamespace(&quot;nombre_del_paquete&quot;) En ambos casos las comillas son obligatorias, y el uso de detach requiere de forma obligatoria el uso de paquete: antes del nombre del paquete. De hecho, unloadNamespace es llamado de forma implicita cuando se usa el argumento unload = TRUE en la llamada a detach. Un namespace, o espacio nombrado no es mas que un espacio en el cual residen objetos (ya sean datos o funciones) que pertenecen a un entorno particular, con nombres unicos que los definen. En cuanto a R, este se puede actualizar a su version mas reciente, pero es dependiente del sistema. La forma mas sencilla segun el FAQ es simplemente desinstalar la version actual de R, y luego instalar la nueva (previamente descargada). Sin embargo, en Windows, es posible utilizar el paquete installr para actualizar R desde dentro de R. En sistema Linux, se puede hacer via terminal por medio del uso de apt-get. 2.1.1 Representación de objetos y el uso de comillas. Antes, aprendiste sobre el proceso de declarar una variable en R. Aunque lo comparamos con la operación matemática de asignar datos a una variable, declarar una variable o un objeto en R es distinto del significado matemático de asignación. Cuando se declara un variable lo que se esta haciendo es crear un nuevo objeto en R que representa al dato que esta almacenando. El nombre del objeto sirve como una referencia (o apuntador) a una dirección de memoria en el disco duro en la que se almacena la información que se le esta asignando al objeto. Esto es importante que lo entiendas: la distinción entre lo que es el objeto y la información o datos. Un caso donde esto puede causar problemas es en la llamada a funciones. Ya hemos hablado acerca de las cadenas de caracteres: son una secuencia de palabras o símbolos encerrados por comillas simples o dobles. En la llamada a la función install.packages dijimos que las comillas son obligatorias, de tal forma que la función entiende que lo que le pasas es una cadena de caracteres que especifica el nombre del paquete que quieres cargar. Ahora, ¿Qué sucedería si olvidas colocar las comillas? (¡no te quedes aquí! Ve a la consola a probar). Bueno, de entrada, R te dirá que ocurrió un error, o puede que no, dependiendo de si el objeto que pasas existe y almacena una cadena de caracteres. Cuando le pasas un objeto a una función (no usas las comillas), R busca un objeto entre los que están presentes en la sesión actual (puedes saber que objetos están en la sesión actual usando ls()) y le pasa a la función el contenido o información que ese objeto esta almacenando. Por ejemplo, supongamos que existe en tu sesión actual un objeto llamado my_obj el cual tiene almacenado la cadena de caracteres \"Radical\". Cuando haces un llamado a install.packages usando el nombre del objeto (es decir, install.packages(my_obj)), lo que en realidad sucede es que estas llamando a la función con la cadena de caracteres almacenada en ese objeto. Es decir, la llamada anterior R la interpreta como install.packages(\"Radical\"). Es importante que entiendas la forma en que funciona el paso de argumentos porque puede generar errores inesperados. Pon en práctica lo que aprendiste. Para la siguiente parte necesitaras instalar el paquete rmarkdown. Instálalo usando lo aprendido en esta sección. Carga el paquete car en la sesión de R y luego la base de datos mtcars usando la función data. Revisa la base de datos llamándola en consola (mtcars es una base de datos que generalmente es utilizada por los principiantes para aprender a programar en R). Ve la documentación para intsall.packages para más información. En Linux, la instalación de paquetes se puede llevar a cabo directamente desde la terminal sin necesidad de iniciar una sesión en R escribiendo el comando R CMD INSTALL ruta/donde/colocaste/paquete.tar.gz.↩︎ En ciencias de Datos (Data Science) con R, el tidyverse consiste de un conjunto de paquetes especializados para el análisis exploratorio e inferencia estadística.↩︎ Puede suceder que la instalación falle si la librería depende de otros paquetes para poder instalarse. Un paquete del cual depende una librería se llama dependencia. En ese caso, coloca el argumento dependencies = TRUE en la llamada a la función. Esto descargara e instalara todas los paquetes de los que depende la librería que quieres instalar y luego instalará el paquete deseado.↩︎ "],["investigación-reproducible-r-markdown..html", "2.2 Investigación reproducible: R Markdown!.", " 2.2 Investigación reproducible: R Markdown!. Anteriormente hablamos sobre los aspectos del flujo de trabajo durante la creación de scripts. R es un lenguaje que facilita mucho la documentación: durante la realización de los programas se pueden dejar comentarios que van explicando paso a paso los acciones realizadas durante el análisis. Esta forma de documentar no solo se refiere a generar código para llevar a cabo un análisis, sino también el registro del porque de las acciones tomadas (p. ej. porque se escogió un modelo estadístico por sobre otro), registro de errores realizados para referencias futuras, notas personales, y otras piezas de información que sirvan a cualquiera que lea tú código para reproducir tus mismos resultados a partir de los datos obtenidos [@Foster]. Ciertamente, el proceso de investigación involucra diferentes partes. Sin embargo, la investigación reproducible hace referencia a la parte de la investigación que comienza cuando ya se tienen los datos crudos (o raw data. Estos son datos no depurados, es decir, que no se han procesado de ninguna manera), y que continua con el análisis, culminando en la generación de resultados. Otras personas deben ser capaces de utilizar tu código y los datos crudos y generar tus mismos resultados. Esta requiere del establecimiento de flujos de trabajo que sean comunes entre los investigadores y analistas, e implica la adopción de un sistema de documentación que ayude a la transparencia y claridad de la investigación y del proceso de análisis. En este sentido, los scripts no ofrecen un buen medio de comunicación, ni un buena infraestructura para la investigación reproducible. Simplemente, ¡hay cosas que no puedes colocar en un script! Por ejemplo, llamadas a instalar paquetes o direcciones de disco duro que solo funcionan en tu computadora. La información relacionada a el lugar donde se encuentran los datos, donde se generan las salidas (como imágenes y archivos PDF), los paquetes necesarios, entre otras cosas, deben de ser conocidas por el analista previo a la realización del análisis. Con este fin, es que R Markdown aparece en escena. Es una forma de hacer seguimiento y llevar registro de todas las cosas que no es posible colocar en un script. Este último contiene el código de análisis, pero los aspectos del flujo de trabajo (direcciones, paquetes, el editor que usas, etc.) vienen especificados de acuerdo las practicas de programación y en documentos de texto estructurados. De esta forma se hace seguimiento, integrando el código con tu propia narrativa de acerca de lo que se esta haciendo (esto es lo que se llama programación literaria). Los documentos de R Markdown se escriben en lenguaje de marcado llamado Markdown, el cual provee una forma de estructurar un documento de forma sencilla. Puede usarse para muchos fines (libros, reportes, paginas web, presentaciones, y mucho más). Para una guía completa de R Markdown, revisa el libro de @Yihui2018, el cual tiene todo lo que necesitas saber sobre R Markdown. También recomiendo el R Markdown Cookbook del mismo autor [@Yihui2020] que puede servir como una referencia rápida. "],["r-markdown-estructura-y-ejecución..html", "2.3 R Markdown: Estructura y Ejecución.", " 2.3 R Markdown: Estructura y Ejecución. En esta sección no pretendo mostrarte todas las funcionalidades de R Markdown (para eso puedes consultar las referencias antes citadas que tienen más de lo que quisieras saber al respecto, y siempre puedes consultar foros y discusiones en la web para buscar ayuda), sino más bien dar una introducción breve a la tecnología de forma que puedas comenzar a realizar tus propios documentos sencillos en nada de tiempo. 2.3.1 Instalando R Markdown. Instalar R Markdown es tan sencillo como instalar el paquete rmarkdown en R. # Instalando rmarkdown desde el repositorio. install.packages(&quot;rmarkdown&quot;) Para poder generar documentos de Latex vas a a necesitar instalar Latex15 (Duh!) en tu computadora. Otra forma es instalando el paquete tinytex en R y luego usar tinytex::install_tinytex()16 para instalar una versión ligera de Latex en tu computadora (la ventaja es que la instalación y uso de TinyTex no requiere de privilegios de administrador). Sea cual sea el tipo de documento que vayas a generar, necesitaras instalado Pandoc para poder generar los documentos. Puedes verificar si ya lo tienes instalado desde R usando: rmarkdown::find_pandoc() Si no se encuentra instalado, puedes encontrar instrucciones de como instalarlo en https://pandoc.org/installing.html. 2.3.2 Anatomía de un documento R Markdown. Para crear documentos de R Markdown solo tienes que especificar las tres partes esenciales que conforman el documento: el encabezado YAML, el texto con formato y los chunks de código. Un ejemplo de un documento de R Markdown muy sencillo y básico es el siguiente: --- title: Mi primer Documento author: Marcelo J. Molinatti S. date: 2021-01-20 output: html_document --- # Introducción. Este es mi primer documento de *R Markdown* que muestra algunas de sus funcionalidades básica. Este documento comenzó con una sección llamada **Introducción** y continua con una subsección que muestra el uso de *chunks* de código. ## Usando *chunks* de código. Puedes utilizar *chunks* de código ya sea dentro de los párrafos que escribes o usando bloques que realicen alguna función. Por ejemplo, el siguiente bloque consiste de una simulación simple de una variable aleatoria continua descrita por una distribución normal (que bien podría ser la distribución de altura de una población) con media $\\mu = 14$ y desviación estándar $\\sigma = 1.2$: ```{r Simulacion} # Simula 100 datos aleatorios de una distribución normal. sim_data &lt;- rnorm(100, mean = 14, sd = 1.2) # Un pequeño histograma... hist(sim_data) ``` Luego puedes hacer uso de *chunks* en línea (*inline chunks*) usando `. Por ejemplo, la media de los 100 datos simulados en el bloque anterior es `r mean(sim_data)`. Puedes guardar este ejemplo en un archivo con extensión *.rmd* (p. ej. lo puedes llamar *mi_ejemplo.rmd*) y luego crear el documento usando la función `render` del paquete `rmarkdown` como: rmarkdown::render(&quot;mi_ejemplo.rmd&quot;, &quot;html_document&quot;) Encabezado YAML Este encabezado contiene lo que se conoce como metadata: información sobre el documento y otras instrucciones que afectan el proceso de generación del documento (también llamado rendering). Este se coloca al inicio del documento: --- title: &quot;Yet another course on R!&quot; author: &quot;Marcelo Molinatti&quot; date: 2021-01-19 output: html_document --- El encabezado comienza y termina con tres guiones (—) que indican el inicio de metadatos YAML (YAML significa Yet Another Markup Language), seguido de tres campos que especifican el titulo del documento, el autor, la fecha y el formato de salida. Es importante que notes que cada campo comienza luego de introducido un espacio en blanco. Los formatos de salida pueden ser distintos: por ejemplo, html_docuemnt especifica que la salida será un archivo HTML, pdf_document especifica que la salida será un PDF, y word_document especifica que será un archivo de Word (existen otros formatos posibles. Consulta @Yihui2018). También puedes especificar argumentos para la salida de forma que puedas modificar ciertos aspectos del documento generado. Por ejemplo: output: html_document: toc: true toc_depth: 2 crea un documento HTML con secciones y subsecciones ennumeradas (toc especifica que se deben numerar y toc_depth especifica cuantos niveles numerar, en este caso, dos niveles). Date cuenta que si pasas argumentos debes indicarlo colocando dos puntos (:) y lo argumentos, si son varios, debes de colocarlos uno después del otro usando saltos de linea. También nota que cada nivel de argumento se especifica con un espacio en blanco (html_document es argumento de output y por eso tiene un espacio en blanco antes. De igual forma, ambos toc y toc_depth son argumentos de html_document y por ello se coloca otro espacio en blanco antes de estos). Texto con formato En esta parte va el contenido de tu documento. Tiene funcionalidades especiales que permiten agregarle formato, de forma que la presentación sea la que tu quieres. Por ejemplo, en el ejemplo, usamos encabezados que permiten definir secciones y subsecciones utilizando los numerales #. Un numeral indica un nivel o una sección del documento, y dos numerales (##) indican una subsección o segundo nivel (este es un nivel que se anida en el nivel externo. Por eso lo llamamos subsección también). Usar tres numerales implica una sub-subsección. Figure 2.1: Opciones de formato de texto (izquierda) con su resultado luego de renderizado (derecha). Tomado de http://uc-r.github.io/r_markdown Además, puedes enfatizar palabras (o îtalizar), encerrando la palabra o frase entre * (o _). Si utilizas dos * (o _) entonces la palabra o palabras son resaltadas en negritas (llamada boldface). Puedes encerrar texto que se entiende como código entre `. En el ejemplo anterior, las palabras render y rmarkdown quiero que se entiendan como código y por eso les dí ese formato. También es posible realizar lista ordenadas (enumeradas) o no. En el caso de listas no numeradas, se pueden construir usando la notación de *. Para las listas enumeradas, se utilizan números para odenar los items. Pro ejemplo: Esta es una lista no numerada: * Este es el primer *item* de la lista. * Este es el segundo *item*, el cual tine eotra lista no numerada anidada. * Este es el primer item de la sublista, anidada en el segundo *item*. * Este es el segundo *item* de la sublista. * Otro *item* de la lista más externa. Este es un ejemplo de una lista numerada u ordenada: 1. El primer *item* enumerado. 1. El segundo *item* numerado. Los número se incrementan automáticamente de forma que no te tienes que preocupar por la numeración de cada uno de los *items*. Las listas pueden anidarse como se ve en el ejemplo anterior, simplemente utilizando una identación adecuada. Además, se pueden mezclar los tipos de lista, de forma que puedes crear listas numeradas con sublistas no numeradas, y viceversa. Muchas otras opciones están disponibles y puedes consultarlas en @Yihui2018. En la figura 2.1 se muestran algunas opciones junto con la salida luego de renderizado el documento. Chunks de código La última característica de un archivo R markdown y la más importante a la hora de generar reportes es la capacidad de añadir fragmentos de código R que se ejecuta. Estos fragmentos pueden resultar en salidas (o outputs, como imágenes, tablas, datos, etc.) que se imprimen y se muestran en el documento generado por la función render al compilar el documento. Para colocar un fragmento de código, colocas {r } encerrado entre tres ` como se muestra en el fragmento que usamos de ejemplo. Luego, colocas el código de R seguido de la última llave (lo cual puede ser el cargado de los datos y paquetes, la manipulación de los datos, análisis estadísticos, entre otras muchas cosas más). Puedes colocar más de un fragmento de código en un documento y cada fragmento nombrarlo usando una etiqueta: para ello, solo coloca un nombre apropiado seguido de la r, dentro de las llaves (p. ej. {r Simulacion} denota un fragmento de código llamado Simulacion. Date cuenta que, como hemos aprendido hasta ahora, la etiqueta debe ser una descripción significativa del fragmento de código). También, los fragmentos de código reciben argumentos: luego de la etiqueta o nombre, se coloca una coma seguido de los argumentos. Algunos argumentos importantes son: echo es un valor lógico que si es TRUE, permite que se imprima el fragmento de código. De lo contrario, el fragmento de código es evaluado (y cualquier resultado aparecera en el reporte final) pero el código no se mostrará en el documento. eval es un valor lógico que si es TRUE, el fragmento de código se ejecuta, de lo contrario, el fragmento de código no se ejecuta (y por lo tanto no hay resultados generados por ese fragmento). include es un valor lógico que de ser FALSE, permite que el código se ejecute, sin incluir el código y los resultados en el documento final. message y warning son también valores lógicos que permiten decidir si se quiere que aparezcan mensajes y advertencias en el documento final. results = 'hide' y fig.show = 'hide' es una forma conveniente de hacer que que no se muestren las salidas y gráficos, respectivamente. Otra funcionalidad de los fragmentos de código es que puedes usar inline chunks (o fragmentos en línea) dentro del texto o contenido. Para ello solo usas r encerrada entre ` (como en `r mean(sim_data)` en el ejemplo). Estos fragmentos sirven para colocar información almacenada en objetos de R, en el contenido del documento (no es tan adecuado para escribir grandes fragmentos de código. En esos casos, es mejor usar un chunk completo). 2.3.3 Imágenes y tablas. Otra parte importante es la capacidad de añadir imágenes y tablas a documentos generados por R Markdown. Para añadir imágenes puedes utilizar el comando: ![Leyenda opcional para la figura](ruta/a/img.png) Una mejor manera de añadir imágenes a un documento es por medio de la función knitr::include_graphics17 incluida en el paquete knitr. ```{r my-figure, echo = FALSE, out.width=&#39;70%&#39;, fig.align=&#39;center&#39;} knitr::include_graphics(&quot;ruta/a/img.png&quot;) ``` La utilidad de esta forma de incluir imágenes es que facilita la personalización por medio de las opciones en los chunks de código. Se pueden utilizar opciones como width, height, fig.align, fig.cap, y/o out.width para especificar el tamaño de la imagen, la alineación, la leyenda de la figura o el tamaño relativo a la amplitud del texto. El poder incluir imágenes a partir de fragmentos de código es lo que permite añadir gráficos generados en R a un documento. En el ejemplo que usamos de base, luego de renderizado el documento vas a a ver un histograma de los datos simulados. Este histograma es generado con la función hist en R, y por lo tanto se imprime en el documento final y, al igual que antes, se puede personalizar su presentación con las opciones del chunk de código. En cuanto a las tablas, la forma más sencilla de generar tablas de datos con un formato personalizado que sea visualmente agradable es utilizando funcione de formato de tablas como knitr::kable(). Por ejemplo, ya dijimos que un conjunto de datos que sirve mucho para aprender a realizar análisis estadísticos en R es mtcars. Un ejemplo de uso de la función de formato de tablas es: ```{r my-table} knitr::kable( mtcars[1:5, ], caption = &quot;A knitr kable.&quot; ) ``` Date un tiempo para leer los argumentos de la función kable de forma que puedas personalizar aun más las tablas que se generan en tus documentos (¿Recuerdas como se lee la documentación de una función?). Otro paquete importante que permite añadir otras características a las tablas es el paquete kableExtra el cual permite estilizar y crear tablas más complejas si así se requiere. Otros paquetes que permiten imprimir tablas más personalizadas son paquetes como xtable, stargazer, pander, tables, y ascii. 2.3.4 Bibliografía y referencias. Es posible generar de forma automática citas y bibliografías en el documento final. Lo único que se tiene que hacer es especificar un archivo de bibliografía usando el campo bibliography en el encabezado YAML. El campo debe especificar la dirección o ruta de acceso del archivo que contiene la bibliografía, y la bibliografía puede estar en formato BibLaTeX, BibTeX, endnote y mnedline. Una forma de automatizar el proceso de creación de una bibliografía es utilizando un manejador de biblioteca (como por ejemplo Mendeley Desktop) de forma que cree el archivo bibliográfico y tu solo tienes que hacer referencia a la dirección de la misma para incluirla en el documento. Para citar algún autor en tu archivo .Rmd se utiliza una clave compuesta por el símbolo @ seguido de un identificador de alguna referencia en el archivo bibliográfico (por ejemplo, @marcelo2020). Si colocas la cita encerrada entre corchetes, entonces la cita es colocada entre paréntesis. Si quieres colocar más de una cita, cada una debe ir separada de la otra por un ; (como en [@marcelo2020; @rodriguez2010]). También puedes añadir comentarios arbitrarios (como cuando se busca hacer referencia a una pagina específica dentro de un trabajo, como en [véase @marcelo2020, pp. 33-35]). Si quieres colocar una cita en el texto (como en … Según Molinatti (2020), …) entonces se omiten los corchetes, y si quieres que solo se imprima la fecha de la publicación a la que haces referencia, pero no el autor, se coloca un - antes del inicio de la cita (como en [-@marcelo2020]). Al renderizar el documento, se construye la bibliografía y se añade al final del documento de forma automática, la cual contendrá cada una de las citas referenciadas dentro del documento. Sin embargo, no se genera una encabezado de forma automática, por lo que es costumbre añadir en un documento un último encabezado o sección para la bibliografía: # Bibliografía. También puedes cambiar el estilo de las referencias (p. ej., si quieres usar las normas APA, puedes usar un documento de estilo que genere las referencias siguiendo estas normas) al hacer uso de un archivo CSL (citation style language) en el campo csldel encabezado YAML. bibliography: bibliografia.bib csl: apa.csl El campo csl debe contener la dirección al archivo con extensión .csl (puedes encontrar estilos bibliográficos en http://github.com/citation-style-language/styles). en el ejemplo anterior, se asume que ambos, bibliografía y estilo (bibliografia.bib y apa.csl, respectivamente) están en el mismo directorio que tu archivo .Rmd. Una vez que se tiene un archivo .Rmd puedes proceder a realizar el renderizado para obtener tu documento. Lo se hace es que una vez finalizado, utilizas la función rmarkdown::render (en el archivo que nos sirve de ejemplo, se utiliza en la consola como rmarkdown::render(\"mi_ejemplo.rmd\", \"html_document\"), de forma que se obtiene el resultado en forma de un archivo HTML), la cual se encarga de pasar el archivo a knitr, el cual se encarga de ejecutar todos los fragmentos de código (estos se ejecutan primero antes del compilado del documento, lo cual se puede aprovechar para colocar fragmentos de código incluso en el encabezado YAML) y crea un documento markdown (extensión .md). Luego Pandoc se encarga de procesar este archivo para generar el documento deseado, ya sea en HTML, PDF, o un documento de Word, presentaciones, entre otros. Listo. Ya puedes comenzar a llevar a cabo reportes, informes, presentaciones y otros documentos que te interesen. En la bibliografía puedes encontrar mucha más información, de forma que seas capaz de explotar todas las funcionalidades que ofrece RMarkdown. Puedes encontrar una en miktex.org. En el caso de Linux, puedes instalarlo desde el repositorio o usar la misma versión de MikTex.↩︎ De aquí en adelante la notación de los pares de dos puntos aparecerá seguido. El operador :: es conocido como operador de resolución de ámbito. Cuando se utiliza como &lt;paquete&gt;::&lt;funcion&gt;(), lo que se hace es especificar que la función llamada &lt;funcion&gt; pertenece al paquete llamado &lt;paquete&gt;. Por ejemplo, tinytex::install_tinytex() indica que la función install_tinytex es una función incluida en el paquete tinytex. Sirve para evitar conflictos o ambigüedades a la hora de llamar funciones. Si hay dos funciones llamadas de la misma forma pero en paquetes diferentes, puedes usar el operador :: y el nombre del paquete para especificar cual de las dos funciones es la que vas a usar.↩︎ Recuerda que :: es el operador de resolución de ámbito. Por lo tanto, include_graphics es una función incluida en el paquete knitr, y por lo tanto, este debe estar instalado.↩︎ "],["notas-finales-sobre-la-investigacion-reproducible..html", "2.4 Notas finales sobre la investigacion reproducible.", " 2.4 Notas finales sobre la investigacion reproducible. "],["estructuras-de-datos..html", "3 Estructuras de Datos. ", " 3 Estructuras de Datos. "],["vectores.html", "3.1 Vectores", " 3.1 Vectores Los vectores son objetos que contienen varios elementos relacionados (del mismo tipo o clase). Estos elementos estan indexados: esto es, cada elemento tiene asociado un numero que determina la posicion del elemento en el vector, comenzando desde el \\(1\\). Las variables creadas asignando un solo valor a ellas son vectores de longitud uno. A estos se les llama atómicos. Los vectores se pueden crear usando la función c(), como en c(\"AC/DC\", \"Led Zeppelin\", Guns &amp; Roses\"). Se pueden añadir tantos elementos como se quiera. Para acceder a los elementos de un vector, se utilizan los operadores de indexado [ y ], encerrando el número que identifica la posición del elemento deseado. Por ejemplo: bandas &lt;- c(&quot;AC/DC&quot;, &quot;Led Zeppelin&quot;, &quot;Guns &amp; Roses&quot;, &quot;Blink 182&quot;) bandas[4] # Devuelve &quot;Blink 182&quot; Empezando a contar desde el 1, el elemento \"AC/DC\", el elemento 4 sería el elemento \"Blink 182\". Es posible saber la longitud de cualquier vector usando la función length. La longitud es el número total de elementos contenidos en el vector. Por ejemplo, el resultado de usar length(bandas) arroja \\(4\\). En la práctica, es usual crear vectores que sean secuencias de números o vectores de elementos que se repiten. En por ello que existen funciones especiales que permiten crear este tipo de vectores. Si se quiere crear una secuencia de números se puede usar seq de la siguiente forma: my_seq &lt;- seq(0, 100) # Primeros 100 numeros naturales pares &lt;- seq(0, 100, by=2) # Numeros pares menores que 100 En las declaraciones anteriores, se especifica con el primer y segundo argumento el comienzo y final de la secuencia, respectivamente. El tercer argumento es opcional: si se omite, cada elemento de la secuencia es mayor al anterior en solo una unidad (el caso de my_seq), de lo contario, cada elemento es el anterior + el numero de unidades que dice by (en el caso de pares, cada elemento es dos veces el anterior). También es posible crear secuencias en la que los elementos esten en orden decreciente. Por ejemplo, seq(-1, -100, by=-2) genera una secuencia de enteros impares negativos mayores que \\(-100\\), comenzando con \\(-1\\), \\(-3\\), \\(-5\\), \\(\\ldots\\). La creación de secuencias de enteros uno a uno (by=1 o by=-1) es tan usual, que existe un atajo para crearlos, usando la notación a:b. Por ejemplo, es posible crear el vector my_seq del ejemplo anterior como 0:100, o uno en sentido descendente como 10:-10. Para crear vectores de repeticiones se usa la función rep de la siguiente forma: my_rep &lt;- rep(&quot;Oh!&quot;, 3) # &quot;Oh!&quot; &quot;Oh!&quot; &quot;Oh!&quot; my_vec_rep &lt;- rep(c(&quot;Wham&quot;, &quot;Bam!&quot;), 2) # &quot;Wham&quot; &quot;Bam!&quot; &quot;Wham&quot; &quot;Bam!&quot; El segundo argumento dice el número de veces que se repite el elemento de entrada. Como se ve en la segunda linea, si el argumento a repetir es un vector, todo el vector se repite el numero de veces que dice el segundo argumento. Se ve que que el resultado es el vector original, seguido del mismo vector, seguido del mismo vector, …, el numero de veces que dice el segundo argumento. Hay otra forma de hacer repeticiones, usando un tercer argumento, each, de la siguiente forma: my_vec_rep &lt;- rep(c(&quot;Wham&quot;, &quot;Bam!&quot;), each=2) # &quot;Wham&quot; &quot;Wham&quot; &quot;Bam!&quot; &quot;Bam!&quot; En este caso, el argumento each dice el numero de veces que cada elemento del vector de entrada se repite. 3.1.1 Operaciones sobre vectores. Las operaciones especificas para un tipo de dato particular, se pueden realizar sobre vectores con elementos de ese tipo de dato. Por ejemplo, las operaciones ariméticas también son válidas sobre vectores, solo se debe conocer la forma como esas operaciones se llevan a cabo. Para empezar sencillo, digamos que queremos crear un vector de los primeros 10 múltiplos de 2. Como vimos antes, se podría hacer con una secuencia, pero aqui estamos interesados en ver como funcionan las operaqciones con vectores. Al realizar operaciones de un vector con un escalar (un atómico), el resultado es un vector en el que cada elemento en la \\(i\\)-esima posición es el elemento \\(i\\) del vector inicial operado con el escalar (atómico). Para dejar esto más clar, el siguiente ejemplo muestra la multiplicación de un escalar por un vector: my_vector &lt;- 1:10 my_vector * 2 Como se puede ver, el resultado de c(1, 2, 3, ..., 10) * 2 es c(1 * 2, 2 * 2, ..., 10 * 2), esto es, cada elemento de my_vector se multuplica pór 2. De manera general, esto ocurre siempre de esta forma. Las operaciones sobre vectores ocurren elemento a elemento. Un caso más complicado surge cuadno queremos realizar operaciones sobre dos vectores de igual longitud: digamos sumar los primeros 10 numeros pares a los primeros 10 numeros impares. first_10_even &lt;- 1:10 * 2 first_10_odd &lt;-first_10_even - 1 first_10_even + first_10_odd Noten el uso de la aritmética de vectores por un escalar para crear los primeros dos vectores. El resultado final muestra que la aritmetica de vectores se hace tomando el elemento en la posición \\(i\\) del primer vector, y opera sobre el elemento en la misma posicion del segundo vector. De forma que al realizar c(2, 4, 6, ..., 20) + c(1, 3, 5, ..., 19), el resultado es c(2 + 1, 4 + 3, ..., 20 + 19). Ahora, ¿qué sucedería si los vectores fuera de longitud distinta?. Por ejemplo, el siguinte ejemplo: 1 : 10 * c(10, 100) muestra que el resultado sigue usando el mismo procedimiento descrito antes, solo que ahora, al llegar al ultimo elemento del vector de menor longitud, se vuelve a usar el primer elemento de ese vector para continuar con la operación. En el caso anterior, la operacion se interpreta como c(1 * 10, 2 * 100, 3 * 10, 4 * 100, 5 * 10, ..., 9 * 10, 10 * 100). A este proceso se le llama reciclado. Cuando se trata de hacer operaciones con vectores de longitud distinta, estas siempre son posibles hacerlas. Sin embargo, si la longitud de un vector no es multiplo de la longitud del otro vector, el proceso de reciclado ocurre de forma incompleta y R lanza una advertencia para que tengas cuidado con lo que esperas. Por ejemplo, si el caso anterior se modifica un poco: 1 : 11 * c(10, 100) Esto se interpreta igual que antes, solo que el ultimo elemento es 11 * 1, el ultimo elemento del vector por el primero del segundo. La advertencia surge debido a que, durante el reciclado, R trata de usar multiplicar los elementos del vector de menor longitud tantas veces como es posible. Pero como el primer vector no tiene suficientes elementos para lograr esto, se lanza la advertencia sobre la diferenciaq de longitudes. Ahora, de igual forma que las operaciones aritméticas son posibles con vectores. las operaciones lógicas también lo son, permitiendo obtener vectores lógicos: vectores cuyos elementos son todos TRUE o FALSE. Por ejemplo: 1:10 &gt;= 5 Al igual que con los vectores de números, las operaciones se hacen elemento a elemento, y en el caso de longitudes distintas, se recicla. Y, al igual que con los vectores numéricos, es posible llevar a cabo operaciones lógicas con vectores de caracteres. Por ejemplo: c(&quot;Eliana&quot;, &quot;Marcelo&quot;, &quot;Darvin&quot;, &quot;Jesus&quot;, &quot;Arianna&quot;) != &quot;Marcelo&quot; Una operación lógica que resulta bastante conveniente, es la que se realiza usando el operador %in%. Este operador lo que hace es chequear si el objeto u objetos (contenidos en un vector) se encuentran representado en los elementos de un vector de posibilidades. Por ejemplo: bands &lt;- c(&quot;AC/DC&quot;, &quot;Led Zeppelin&quot;, &quot;Guns &amp; Roses&quot;, &quot;Blink 182&quot;, &quot;Neck Deep&quot;, &quot;State Champs&quot;, &quot;Green Day&quot;, &quot;The Offsprings&quot;) bands %in% c(&quot;AC/DC&quot;, &quot;Led Zeppelin&quot;, &quot;Guns &amp; Roses&quot;, &quot;The Offsprings&quot;) El resultado es un vector con un TRUE en las posiciones en las que se encuentra un elemento que coincide con alguno de los elementos en el vector a la derecha del operador %in%. 3.1.2 Vectorización y funciones. La razón por la que es posible realizar operaciones de forma tan sencilla en R, es debido a que el lenguaje esta vectorizado. Esto quiere decir, que las operaciones ocurren en todos los elemento de un vector sin la necesidad de iterar18 por cada uno de los elementos, uno a la vez. La vectorización es también lo que hace posible el uso de funciones sobre vectores. Por ejemplo, si se tiene un vector con los primeros 100 enteros, y se quiere saber la raíz cuadrada de cada uno de ellos, solo es necesario aplicar la función al vector: sqrt(1:100). Esto se interpreta como: c(sqrt(1), sqrt(2), ..., sqrt(100)). De igual forma, todas las funciones matemáticas en R estan vectorizadas para operar sobre todos los elementos a la vez. Muchas funciones en R estan vectorizadas. Es lo que lo hace tan conveniente. Y muchas funciones que realizan tareas usualmente encontradas en análisis de datos y otras aplicaciones, estan disponibles en R para facilitar el trabajo y no tener que reinventar la rueda cada vez. Estas funciones operan sobre vectores, devolviendo un atómico como resultado. Por ejemplo, varias funciones usuales que operan sobre vectores son las siguientes: min(-10:10) # minimo de un numero max(-10:10) # Maximo de un numero prod(1:10) # Factorial sum(1:10) # Sumatoria La ultima función es particularmente útil cuando quieres contar el numero de elementos que cumplen una condición. Por ejemplo, digamos que queremos saber cual es el número de elementos mayores a \\(50\\) en una muestra de \\(100\\) elementos tomados al azar de un vector de numeros enteros en el intervalo \\([1, 100]\\). El código para realizar esta tarea es el siguiente: my_sample &lt;- sample(1:100, 100, replace=TRUE) sum(my_sample &gt; 50) La función sample recibe un vector y un numero que dice cuantos elementos se tomaran de muestra del vector. El argumento replace dice que una vez que se toma un elemento, este se anota y se devuelve de forma que este disponible para poder tomarlo una vez más19 Luego, la condición dentro de la función sum genera un vector lógico con TRUE donde haya elementos mayores a \\(50\\). Como los vectores lógicos se interpretan como \\(1\\) (TRUE) y \\(0\\) (FALSE) internamente; cuando se aplica sum, esta se encarga de sumar solo 1’s y 0’s. De esta forma, es fácil realizar conteos en R. Otras funciones útiles son any y all, las cuales devuelven un valor lógico. any devuelve TRUE si un vector lógico contiene al menos un TRUE, de otra forma regresa FALSE. all devuelve TRUE si todos los elementos de un vector son TRUE, de otra froma regresa FALSE. Estas funciones son muy útiles en combianción con operadores lógicos: my_sample &lt;- c(1, 15, 8, 2, 14, 7, 2, 14, 29) any(sum(my_sample %% 7) &gt; 0) # TRUE ya que hay multiplos de cero en my_sample all(sum(my_sample %% 2) &gt; 0) # FALSE porque no todos los elementos de my_sample son pares La función sample es como otras funciones en R que reciben un vector (y posiblemente otros argumentos) y devuelven más vectores como resultado. Por ejemplo, podemos tener un vector de elementos desordenados, y puede que queramos ordenarlo de forma creciente: cat(&quot;Antes de ordenar:\\n&quot;, my_sample, &quot;\\nDespues de ordenar:\\n&quot;, sort(my_sample)) La función cat se encarga de imprimir objetos en R, combinándolos primero. Funciones estadísticas Existen un conjunto de cálculos matemáticos en el análisis de datos que son tan frecuentes, que ya están programadas por omisión dentro de R. Estas funciones son mean, var, sd, median, range, quantile y cor, las cuales reciben un vector numérico, y devuelven la media, varianza, desviación estándar, mediana, rango, y los cuantiles, respectivamente. El código siguiente muestra el calculo de las medidas de tendencia central y dispersión para un vector. c(Media=mean(my_sample), Mediana=median(my_sample), Var=var(my_sample), Std.Error=sd(my_sample)) La función range devuelve un vector con dos elementos, los valores con magnitud máxima y minima range(my_sample) La funcion quantile devuelve los cuartiles calculados a partir de la muestra. Noten que el \\(Q_{50\\%}\\) es la mediana, y \\(Q_{0\\%}\\) y \\(Q_{100\\%}\\) son el valor mínimo y máximo devueltos por range. quantile(my_sample) Ahora, podemos ver en mas detalle la función sample. Esta es muy útil para realizar simulaciones. Pero también lo es en el análisis de datos, ya que permite seleccionar de forma aleatoria un conjunto de datos que puede servir como un conjunto de datos independiente del ajuste de un modelo por ejemplo. Esta funcion permite tomar una muestra aleatoria a partir de un vector que es dado como argumento a la función. El tamaño de la muestra a tomar se puede especificar como el segundo argumento, size, el cual por omisión es igual a la longitud del vector. El argumento replace es un valor lógico que indica si el muestreo se hace con reemplazo o sin reemplazo, y el ultimo argumento, prob, es un vector de probabilidades que permite especificar la frecuencia que se espera tenga un elemento en el vector. Por omisión, esta es igual para todos los elementos. Datos Faltantes (Missing). Como ya vimos anteriormente, NA es un objeto especial en R que significa que hay un dato faltante. Vimos que es posible comprobar si un objeto es un dato faltante usando la función is.na(), la cual devuelve TRUE si es NA, y FALSE de otra forma. Los datos faltantes son comunes en el análisis de datos y deben tratarse de manera adecuada durante el proceso previo al análisis, e incluso, durante el análisis. Por ejemplo, digamos que se quiere calcular la media del siguiente vector: vec_w_NA &lt;- c(1, 17, 25, NA, 42, 23, 8, 27, NA, 17) mean(vec_w_NA) Como se observa, el vector tiene dos datos faltantes, y al calcular la media, el resultado es un NA. La razón de esto, es que no es posible realizar cálculos con datos faltan tes. Es por ello que se deben eliminar antes de realizar el calculo. Sin embargo, no es necesario hacerlo de manera explicita, dado que las funciones estadísticas contienen argumentos que permiten eliminar de forma automática los NA del calculo. mean(vec_w_NA, na.rm=TRUE) En la siguiente parte, veremos como podemos utilizar expresiones lógicas para obtener un conjunto de datos libre de NA. 3.1.3 Indexado usando expresiones lógicas. En R, una expresión es toda frase o segmento de código que puede ejecutarse. Al escribir una linea de código, se esta creando una expresión de R que puede ser evaluada (al oprimir Enter). Las expresiones evaluadas pueden mantenerse en memoria o tener desaparecer inmediatamente, dependiendo de si se almacena el resultado de la evaluación en una variable u objeto. En este caso, la expresión es denominada asignación. Expresiones lógicas Una expresión lógica es un tipo especial de expresión de R que utiliza operadores lógicos de comparación para crearlas, y cuyo valor de retorno es siempre un valor lógico (TRUE o FALSE). Ademas, también hace uso de los operadores lógicos &amp; (and), | (or) y ! (not): &amp; (and): se escribe expresion_1 &amp; expresion_2, donde expresion_1 y expresion_2 son ambas expresiones lógicas. Devuelve TRUE si ambos expresion_1 y expresion_2 son TRUE, y devuelve FALSE, si una de las dos, o ambas expresiones, son FALSE. | (or): se escribe expresion_1 | expresion_2, donde expresion_1 y expresion_2 son ambas expresiones lógicas. Devuelve TRUE si alguna o ambas expresiones son verdaderas, y FALSE si ambas son FALSE. ! (not): se escribe !expresion_1 (es un operador unario, a diferencia de los anteriores. unario significa que recibe un solo operando), donde expresion_1 es una expresión lógica. Devuelve TRUE si la expresión es FALSE, y devuelve FALSE si la expresión es TRUE. Por ejemplo, digamos que tenemos dos vectores numéricos y queremos realizar una acción sobre ellos. Pero antes de realizar cualquier acción, se necesita asegurar que todos los valores sean positivos y que al menos alguno sea mayor a \\(50\\). Podemos verificar ambas expresiones lógicas como sigue: my_sample &lt;- sample(1:100, 100, replace=TRUE) all(my_sample &gt; 0) &amp; any(my_sample &gt;= 50) También es posible utilizar el operador | en el ejemplo anterior, y el resultado podría variar dependiendo de my_sample. En el caso del operador !, se puede usar como sigue: !all(my_sample &gt; 0) Los operadores lógicos indicados evalúan ambas expresiones antes de arrojar un resultado final. Existen otro par de operadores lógicos que no necesariamente evalúan ambas expresiones: los operadores &amp;&amp; y ||. Estos operadores permiten ahorrar tiempo a la hora de evaluar expresiones lógicas, dado que se puede escapar tempranamente de la expresión si la condición de la izquierda no cumple una condición. Un ejemplo que facilita el entendimiento de estos operadores es la división entre cero. Podemos intentar evaluar si \\(sen(1/x)\\) es igual a cero, sin(1 / x) == 0. Pero dado que la división entre cero no esta definida, hay que verificar que \\(x\\) no sea cero, y en caso de serlo, no realizar la evaluación de sin(1 / x) == 0. Si se hiciera de la forma usual: x &lt;- 0 (x == 0) | (sin(1 / x) == 0) el resultado es TRUE ya que el operando de la derecha es NA, por lo que se ignora al evaluar la expresión TRUE | NA. Al usar la expresión: (x == 0) || (sin(1 / x) == 0) no arroja ninguna advertencia debido a que ahora, la expresión de la derecha no se evalúa hasta que la expresión de la izquierda no es FALSE. La razón de esto, es que cuando se usa el operador or, si la primera expresión es FALSE, todavía hay posibilidad de que toda la expresión expresion_1 || expresion_2, sea TRUE. Por lo tanto, la expresión de la derecha solo se evalúa si aun hay oportunidad de que la expresión total sea TRUE. El operador &amp;&amp; funciona de forma similar, pero la expresión de la izquierda solo se evalúa si la expresión de la derecha es TRUE, dado que si esto ocurre, aun hay oportunidad de que al expresión completa sea FALSE, si la expresión de la derecha es FALSE. Indexado por expresiones lógicas. Las expresiones lógicas son muy útiles para indexar vectores basado en el resultado de la expresión. El indexado devuelve solo los elementos del vector para los cuales el resultado de la expresión es TRUE. Esto requiere que la longitud del resultado de la expresión lógica sea igual; a la longitud del vector que se busca indexar. Por ejemplo, podemos seleccionar los elementos de un vector diferentes de NA usando: vec_w_NA[!is.na(vec_w_NA)] ## [1] 1 17 25 42 23 8 27 17 En el análisis estadístico de datos, es sencillo seleccionar aquellos elementos por encima de la media, o mas importante aun, seleccionar datos atípicos de una muestra. Un dato se considera atípico si cae a mas de dos desviaciones estándar de la media. De forma que se pueden seleccionar usando: my_sample &lt;- c(1, 3, 11, 5, 15, 8, 2, 14, 7, 2, 14, 29, 55) my_sample[(my_sample - mean(my_sample)) / sd(my_sample) &gt; 2] ## [1] 55 Los NA causan problemas en el indexado de expresiones logicas, y por tanto afectan el resultado de la evaluacion de expresiones de indexado: vec_w_NA[vec_w_NA &gt; mean(vec_w_NA, na.rm=TRUE)] ## [1] 25 NA 42 23 27 NA El resultado, como se espera contiene NA, porque son ignorados en la expresion de indexado. Para evitar esto, es mejor utilizar la funcion subset, la cual permite ignorar los NA en el vector: subset(vec_w_NA, vec_w_NA &gt; mean(vec_w_NA, na.rm=TRUE)) ## [1] 25 42 23 27 Otra función de importancia en el indexado por expresiones lógicas es which. Esta recibe una expresión lógica, y devuelve las posiciones en el vector resultante de la expresión lógica en los cuales el resultado es TRUE. Por ejemplo: which(my_sample &gt; mean(my_sample)) ## [1] 5 8 11 12 13 Como esta devuelve posiciones en el vector donde se cumple una condición, es posible usarlo en para indexar el vector, u otro vector relacionado, usando my_sample[which(my_sample &gt; mean(my_sample))]. La iteración se hace con unas estructuras de control llamados loops (bucle), como lo son los ciclos for o while. En R, estas estructuras estan disponibles, pero la vectorización no las hace indispensables en muchas aplicaciones.↩︎ A este proceso se le llama tomar una mustra con reemplazo en la teoría de muestras.↩︎ "],["marices-y-arreglos..html", "3.2 Marices y arreglos.", " 3.2 Marices y arreglos. Las matrices y arreglos no suelen aparecer como estructuras en el análisis de datos. Pero debido a que las tablas de contingencia oara multiples variables categoricas presentan multidimensionalidad como las matrices y arreglos, estas se describirán de forma breve y por completitud. 3.2.1 Matrices. Las matrices en R se construyen a partir de vectores usando la función matrix, y especificando atributos de esta clase de objetos que determinan las dimensiones de la matriz. Para crear vectores columna, de orden \\(k\\times1\\) se usa: matrix(1:5) ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 Por omisión, si no se especifica los atributos de dimension, la matriz creada es un vector columna (en un sentido matematico, y no un objeto vector como los vistos antes). Un vector fila se puede crear especificando el argumento ncol como la longitud del vector que se pasa como argumento: matrix(1:5, ncol=5) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 Para crear matrices rectangulares o cuadradas se usan los argumentos ncol o nrow o ambos: matrix(1:6, nrow=2) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 Deben notar que la matriz es generada colocando los elementos columna a columna. Si se quiere generar una matriz cuyos elementos se coloquen fila a fila, se debe usar el argumento byrow como sigue: my_matrix &lt;- matrix(1:6, nrow=2, byrow=TRUE) my_matrix ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 Otra forma de crear matices a partir de vectores es usando las funciones rbind y cbind, las cuales unen dos vectores usándolos como filas o columnas, respectivamente. rbind(1:6, 10:16) cbind(1:6, 10:16) Notamos que, si es necesario, se realiza el reciclado de elementos para obtener un resultado consistente, dejando una advertencia que nos dice tengamos cuidado. Es posible realizar operaciones aritméticas en matrices de la misma forma que con los vectores, siempre y cuando los operandos sean del mismo orden (igual dimensión): my_matrix + my_matrix my_matrix - my_matrix my_matrix * my_matrix my_matrix / my_matrix Al correr las expresiones anteriores, notara que al igual que en los vectores, las operaciones aritméticas se realizan elemento a elemento. En matemática, el producto de matrices no se hace elemento a elemento. Es por eso que existe un operador de producto matricial %*% que se encarga de llevar a cabo la operación producto de la forma usual: my_matrix %*% my_matrix El numero de columnas de la matriz de la izquierda debe ser igual al numero de fila de la matriz de la derecha. Las operaciones aritméticas usando como operandos una matriz y un vector son posibles llevarlas a cabo, debido a un proceso llamado coerción. La coerción se refiere al intento de transformar un objeto de una clase a un objeto de otra clase para que la operación pueda llevarse a cabo. Solo se debe tener cuidado con la forma en la que las operaciones se llevan a cabo. matrix(1:6, nrow=2) * 1:4 ## Warning in matrix(1:6, nrow = 2) * 1:4: longitud de objeto mayor no es ## múltiplo de la longitud de uno menor ## [,1] [,2] [,3] ## [1,] 1 9 5 ## [2,] 4 16 12 Como se observa, el vector es coercionado a un objeto de clase matriz, y luego, la operación se hace por columnas, en este caso, multiplicando los elementos de la primera columna de la matriz con los elementos del vector, luego la segunda columna, luego la tercera, y asi sucesivamente, reciclando el vector si es necesario hasta que todos los elementos de la matriz hayan sido operados. Si la longitud del vector no es divisor de \\(m\\times n\\) (\\(m\\) son el numero de filas, y \\(n\\) el numero de columnas de la matriz), se lanza una advertencia. Nota sobre Coerción de objetos. La coerción de objetos es algo inocuo en R. Por ejemplo, cuando realizamos la operación 1L + 3.5, se esta realizando la suma de un objeto de clase integer y uno de clase numeric. De forma implicita, el interprete de R se encarga de coercionar el integer a un objeto de clase numeric para realizar la suma, y devuelve un objeto de la clase apropiada. Esto ya se ha visto antes al usar valores lógicos para contar el numero de elementos que cumplen una condicion. sum funciona, por que es capaz de coercionar los valores logical a numeric, de tal forma que la suma tenga sentido. Es por eso que expresiones de la forma TRUE + TRUE no generan problemas (aunque no es algo que vayas a encontrar en un programa). También es posible construir expresiones lógicas usando matrices al igual que antes, de forma que se obtienen matrices lógicas. Ademas, las expresiones lógicas se pueden utilizar para indexar las matrices. El indexado de matrices se puede hacer especificando la posicion en la fila y la columna. my_matrix[2, 3] # elemento de la segunda fila y tercera columna my_matrix[2, ] # toda la segunda fila. vector my_matrix[, 1] # toda la primera columna. vector my_matrix[, 1, drop=FALSE] # toda la primera columna. En forma de matrix Varias funciones pueden aplicarse sobre la matriz para conocer atributos de la misma: nrow: devuelve el numero de filas de la matriz que recibe como argumento. ncol: devuelve el numero de filas de la matriz que recibe como argumento. dim: devuelve un vector cuyos elementos son el numero de filas y columnas de la matriz Otras funciones permiten realizar cálculos usuales realizados en álgebra lineal como la traspuestas, t; el determinante, det, si la matriz es cuadrada; o si la matriz es cuadrada e invertible, se puede obtener la inversa usando solve(my_matrix). La función solve también recibe como segundo argumento un vector, de forma que permite resolver un sistema de ecuaciones lineales usando descomposición de valor singular. 3.2.2 Arreglos. Los arreglos son útiles cuando se necesitan estructuras de mas de dos dimensiones. Estos pueden aparecer al construir tablas de contingencia a partir de tres o mas variables nominales u ordinales. Para construir un arreglo de dimensiones \\(n\\times m\\times k\\), solo se debe usar la función array, pasando un vector cuya longitud sea prod(dim(array)), y un vector que especifique las dimensiones. Por ejemplo: array(c(my_sample, 5), c(2, 3, 2)) genera un arreglo de 2 matrices (el tercer elemento de la dimensión), cada una con dos filas y tres columnas. "],["factores.html", "3.3 Factores", " 3.3 Factores Los factores son un tipo de dato especial en R que permite almacenar de forma eficiente datos categoricos: nominales u ordinales. Estos se construyen, al igual que las matrices, a partir de vectores. Y asi como las matrices, los factores tienen un atributo que los diferencia de vectores ordinarios. Este atributo se refiere a los niveles (levels) del factor: los valores posibles de un factor. En el análisis de datos, es de vital importancia ya que el comportameinto de modelos estadisticos depende del tipo de los valores de entrada, además de que muchas funciones estadísticas en R tratan los factores de manera distinta a como se tratan los vectores de carcateres. Para crear un factor se usa la función factor: rating &lt;- c(&quot;Very Bad&quot;, &quot;Medium&quot;, &quot;Very Bad&quot;, &quot;Good&quot;, &quot;Medium&quot;, &quot;Very Good&quot;, &quot;Medium&quot;, &quot;Good&quot;, &quot;Medium&quot;, &quot;Bad&quot;) rating_factor &lt;- factor(rating) rating_factor ## [1] Very Bad Medium Very Bad Good Medium Very Good Medium ## [8] Good Medium Bad ## Levels: Bad Good Medium Very Bad Very Good El resultado muestra los elementos del factor, y debajo, las etiquetas de los niveles del factor. Podemos ver que este es distinto de un vector de caracteres: typeof(rating_factor) ## [1] &quot;integer&quot; El tipo de los elementos almacenados en el vector es integer. Esto es asi porque los factores se representan como enteros internamente. Los niveles son etiquetas asociadas a cada uno de esos enteros. Se puede saber los niveles de un factor usando la función levels: levels(rating_factor) ## [1] &quot;Bad&quot; &quot;Good&quot; &quot;Medium&quot; &quot;Very Bad&quot; &quot;Very Good&quot; la cual devuelve un vector de caracteres con las etiquetas de los niveles, en orden alfabético. Esto ocurre así por omisión: los niveles de un factor se almacenan en orden alfabético. Sin embargo, podemos especificar el orden en el que se almacenan las etiquetas al crear el factor: rating_factor &lt;- factor(rating, levels=c(&quot;Very Bad&quot;, &quot;Bad&quot;, &quot;Medium&quot;, &quot;Good&quot;, &quot;Very Good&quot;)) rating_factor ## [1] Very Bad Medium Very Bad Good Medium Very Good Medium ## [8] Good Medium Bad ## Levels: Very Bad Bad Medium Good Very Good Esto es importante cuando se quiere especificar un nivel de referencia con el cual comparar los resultados de un modelo estadistico. Por ejemplo, si en un estudio se busca usar como variable independiente el habito de fumar, codificado como Fumador y No Fumador, tiene sentido usar el nivel de No Fumador como referencia, de forma que cualquier analisis que use un modelo estadistico compare el cambio en la respuesta como consecuencia del habito de fuumar. Sin embargo, al crear un factor, debido a que se almacenan alfabéticamente los niveles, el nivel Fumador quedaría como nivel de referencia: smoker &lt;- c(&quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;, &quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;) smoker_factor &lt;- factor(smoker) smoker_factor ## [1] No Fumador Fumador No Fumador No Fumador Fumador Fumador ## [7] No Fumador Fumador Fumador No Fumador ## Levels: Fumador No Fumador Es por ello, que resulta conveniente el uso del argumento levels en la función factor: smoker &lt;- c(&quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;, &quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;) smoker_factor &lt;- factor(smoker, levels=c(&quot;No Fumador&quot;, &quot;Fumador&quot;)) smoker_factor ## [1] No Fumador Fumador No Fumador No Fumador Fumador Fumador ## [7] No Fumador Fumador Fumador No Fumador ## Levels: No Fumador Fumador Hasta este momento, hemos asumido que los factores que hemos creado corresponden a representaciones de variables catgoricas nominales. Para crear factores que correspondan a representaciones de variables catgoricas ordinales, se puede hacer especificando el argumento ordered=TRUE en la funcion factor; o se puede hacer directamente usando la función ordered: # Este ordenamiento tiene sentido en escalas tipo Likert rating_factor &lt;- factor(rating, levels=c(&quot;Very Bad&quot;, &quot;Bad&quot;, &quot;Medium&quot;, &quot;Good&quot;, &quot;Very Good&quot;), ordered=TRUE) rating_factor &lt;- ordered(rating, levels=c(&quot;Very Bad&quot;, &quot;Bad&quot;, &quot;Medium&quot;, &quot;Good&quot;, &quot;Very Good&quot;)) El especificar de forma explicita los niveles tiene otra ventaja importante: Permite detectar tempranamente errores de codificación de elementos dentro de una variable. Por ejemplo, digamos que al definir el vector smoker cometimos un error de tipeo, y uno de los elementos lo escribimos \"Funador\" (tecleamos N en lugar de M). Al crear el factor con los niveles especificados: smoker &lt;- c(&quot;No Fumador&quot;, &quot;Funador&quot;, &quot;No Fumador&quot;, &quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;) # El segundo elemento tiene el error de tipeo smoker_factor &lt;- factor(smoker, levels=c(&quot;No Fumador&quot;, &quot;Fumador&quot;)) smoker_factor ## [1] No Fumador &lt;NA&gt; No Fumador No Fumador Fumador Fumador ## [7] No Fumador Fumador Fumador No Fumador ## Levels: No Fumador Fumador vemos como el factor contiene un NA donde ocurrió el error de tipeo. Esto es un problema, ya que pueden introducirse de forma inesperada datos faltantes donde no los hay, y, peor aún, R no nos advierte de nada de esto. Es posible evitar este comportamiento usando parse_factor en el paquete readr (que usaremos mas adelante para importar datos). Ahora, al crear el factor, R nos muestra una advertencia de que algo no salió como se esperaba, haciendonos sospechar del resultado y que seamos cuidadosos. library(readr) smoker_factor &lt;- parse_factor(smoker, levels=c(&quot;No Fumador&quot;, &quot;Fumador&quot;)) # Genera una advertencia ## Warning: 1 parsing failure. ## row col expected actual ## 2 -- value in level set Funador smoker_factor # Imprime el resultado anterior, pero tambien la advertencia, y donde ocurrió ## [1] No Fumador &lt;NA&gt; No Fumador No Fumador Fumador Fumador ## [7] No Fumador Fumador Fumador No Fumador ## attr(,&quot;problems&quot;) ## # A tibble: 1 × 4 ## row col expected actual ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 NA value in level set Funador ## Levels: No Fumador Fumador Buenas prácticas de programación. De forma general, al crear factores, siempre es mejor hacer explicitos los niveles y, aunque las advertencias son adecuadas para manjar con cuidado resultados inesperados como los del ejemplo anterior, siempre es preferible no crear factores que de entrada sabemos son erroneos. Para evitar la creación de factores mal especificados, se utiliza la función fct en el paquete forcats (un paquete diseñado especificamente para trabajar con factores), el cual se diferencia de factor en que los niveles se crean en el orden en que aparecen en el vector de entrada, y no alfabéticamente. library(forcats) smoker &lt;- c(&quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;, &quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;, &quot;Fumador&quot;, &quot;Fumador&quot;, &quot;No Fumador&quot;) smoker_factor &lt;- fct(smoker, levels=c(&quot;No Fumador&quot;, &quot;Fumador&quot;)) Crear factores ordenados no es tan directo, pero el beneficio de crear factores correctos desde el inicio es más importante: # Especificando los niveles rating_factor &lt;- fct(rating, levels=c(&quot;Very Bad&quot;, &quot;Bad&quot;, &quot;Medium&quot;, &quot;Good&quot;, &quot;Very Good&quot;)) %&gt;% lvls_reorder(1:5, ordered=TRUE) El simbolo %&gt;% es un operador, el operador de tuberia (de la palabra inglesa pipe), el cual se carga en la sesión de R al cargar el paquete forcats. El uso de este operador se difiere hasta el siguiente capitulo. En este momento es suficiente que entienda que cada vez que aparezca una expresión de la forma objeto %&gt;% funcion(primer_arg, segundo_arg, ...), R lo interpreta como funcion(objeto, primer_arg, segundo_arg, ...). Otras funciones importantes para manejar factores, junto con un ejemplo de su uso, se presenta a continuación20: fct_relevel: nos permite jugar con el orden de los niveles de un factor. Por ejemplo: fct(c(&quot;Fuego&quot;, &quot;Tierra&quot;, &quot;Agua&quot;, &quot;Aire&quot;)) %&gt;% fct_relevel(&quot;Agua&quot;, &quot;Tierra&quot;, &quot;Fuego&quot;) fct_inorder, fct_infreq: estas se encargan de ordenar los niveles de un factor en el orden en el que aparecen (fct_inorder) o en el orden especificado por la frecuencia con que aprece cada etiqieta (fct_infreq). vertebrates &lt;- fct(sample(c(&quot;Mamifero&quot;, &quot;Ave&quot;, &quot;Reptil&quot;, &quot;Pez&quot;, &quot;Anfibio&quot;), 250, replace=TRUE)) invertebrate &lt;- fct(sample(c(&quot;Diptero&quot;, &quot;Odonata&quot;, &quot;Porifera&quot;, &quot;Cnidario&quot;, &quot;Aracnido&quot;), 25, replace=TRUE)) animal_cat &lt;- fct_c(vertebrates, invertebrate) # fct_c permite combinar factores, preservando los niveles de los factores de entrada animal_cat %&gt;% fct_infreq() fct_lump y fct_lump_*: estas funciones permiten agrupar niveles, preservando un numero especificado de veeces o solo aquellos niveles de baja frecuencia. animal_cat %&gt;% fct_lump_lowfreq(other_level = &quot;Invertebrados&quot;) fct_expand: permite añadir niveles adicionales a un factor, ya sea que existan o no representastes de estos niveles en el factor. animal_cat %&gt;% fct_expand(&quot;Himenoptero&quot;, &quot;Platelmintos&quot;, &quot;Equinodermos&quot;, &quot;Anfioxo&quot;, after=5) fct_collapse: permite agrupar los niveles en niveles nuevos manualmente definidos. animal_cat %&gt;% fct_collapse( Vertebrados=c(&quot;Mamifero&quot;, &quot;Ave&quot;, &quot;Reptil&quot;, &quot;Pez&quot;, &quot;Anfibio&quot;), Invertebrados=c(&quot;Diptero&quot;, &quot;Odonata&quot;, &quot;Porifera&quot;, &quot;Cnidario&quot;, &quot;Aracnido&quot;)) fct_drop: devuelve un factor cuyos niveles son solo aquellos representados dentro del factor. animal_cat %&gt;% fct_expand(&quot;Angiospermas&quot;) %&gt;% # Añade un nivel llamado Angiospermas fct_drop() fct_other: Reemplaza los niveles especificados con un nivel especificado (por omisión, “other”). animal_cat %&gt;% fct_expand(&quot;Himenoptero&quot;, &quot;Platelmintos&quot;, &quot;Equinodermos&quot;, &quot;Anfioxo&quot;, after=5) %&gt;% fct_other(keep = c(&quot;Mamifero&quot;, &quot;Ave&quot;, &quot;Reptil&quot;, &quot;Pez&quot;, &quot;Anfibio&quot;, &quot;Anfioxo&quot;), other_level=&quot;Sin notocordio&quot;) # Deja los cordados fct_count: cuenta el numero de elmentos del factor que pertenece a cada nivel. El resultadoe s una estructura de datos especial llamada tibble que veremos en la siguiente sección. animal_cat %&gt;% fct_count(sort=TRUE) Más información esta disponible en la documentación.↩︎ "],["tablas-de-datos-data-frames..html", "3.4 Tablas de Datos (data frames).", " 3.4 Tablas de Datos (data frames). "],["listas..html", "3.5 Listas.", " 3.5 Listas. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
